#pragma config(Sensor, in1,    rightArmPot,    sensorPotentiometer) 
#pragma config(Sensor, in2,    leftArmPot,     sensorPotentiometer) 
#pragma config(Motor,  port1,           rightIntake,   tmotorVex393, openLoop) 
#pragma config(Motor,  port2,           rightFrontDrive, tmotorVex393, openLoop, reversed) 
#pragma config(Motor,  port3,           rightBackDrive, tmotorVex393, openLoop, reversed) 
#pragma config(Motor,  port4,           rightTopArm,   tmotorVex393, openLoop) 
#pragma config(Motor,  port5,           rightBottomArm, tmotorVex393, openLoop) 
#pragma config(Motor,  port6,           leftTopArm,    tmotorVex393, openLoop, reversed) 
#pragma config(Motor,  port7,           leftBottomArm, tmotorVex393, openLoop, reversed) 
#pragma config(Motor,  port8,           leftFrontDrive, tmotorVex393, openLoop) 
#pragma config(Motor,  port9,           leftBackDrive, tmotorVex393, openLoop) 
#pragma config(Motor,  port10,          leftIntake,    tmotorVex393, openLoop, reversed) 
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*// 
  
/************************************************************************* 
VEX - Joystick Control 
  
Description: This program allows teleoperated control of our 15" robot 
with the VEX Joystick controller.  An infinite while loop (BLT) is used 
to continually update the power level of the motor ports based on the 
values provided by the transmitter.  It controls the drivetrain, arm, and 
intake systems. 
  
-   Parameters and information for vexRT: 
        Ch1 = Right Joystick X-axis 
        Ch2 = Right Joystick Y-axis 
        Ch3 = Left Joystick Y-axis 
        Ch4 = Left Joystick X-axis 
        Ch5 = Rear Left Buttons 
        Ch6 = Rear Right Buttons 
  
        Read joysticks with:    vexRT[Ch3] 
        Read buttons with: vexRT[Btn6U] 
  
*************************************************************************/
  
  
/* updated 2/18, JK 
  
Changes: 
  
- deadband is abstracted out to a function 
- there are now separate deadband thresholds for drive and arm (both globals) 
- setDrive, setArm, and setIntake functions have been written 
- new function for opertating arm with buttons written (setArm_button) 
  
  
Next steps: 
  
- verify deadband function 
- verify setDrive, setArm, and setIntake 
- use setDrive, setArm, and setIntake in main 
- test setArm_button 
- functions could be moved to separate .c file? (more organized) 
  
*/
  
  
  
  
  
// globals - this is needed for deadband to be used in other functions 
const int driveDeadbandThreshold = 20; // used to deadband drive system 
const int armDeadbandThreshold = 20; // used to deadband arm system - still tweakable 
const int rightArmUpperLimit = 3670; // potentiometer upper limit for right arm 
const int rightArmLowerLimit = 930; // potentiometer lower limit for right arm 
  
// deadband function 
int deadband( int input, int threshold) 
{ 
    if (abs(input) < threshold) 
        {input = 0;} 
    return input; 
} 
  
  
// drive functions 
void setDriveMotors( int rightValue, int leftValue) // lets you set all the drive motors in one call 
{ 
    motor[rightFrontDrive] = rightValue; // rightFrontDrive - 2 
    motor[rightBackDrive] = rightValue;  // rightBackDrive - 3 
    motor[leftFrontDrive] = leftValue;   // leftFrontDrive - 8 
    motor[leftBackDrive] = leftValue;    // leftBackDrive - 9 
} 
  
void setDrive() 
{ 
    int driveJoystickY = vexRT[Ch3];  // read from the left josytick Y-axis (channel 3) 
    int driveJoystickX = vexRT[Ch4];  // read from the left josytick X-axis (channel 4) 
    // both originally divided by 2 to prevent numbers over 127 - maybe try clipping function in the future 
    int rightMotorValue = driveJoystickY - driveJoystickX;                              // arcade drive left side value 
    int leftMotorValue = driveJoystickY + driveJoystickX;                                   // arcade drive right side value 
  leftMotorValue = deadband(leftMotorValue, driveDeadbandThreshold);        // deadband the left motor value 
    rightMotorValue = deadband(rightMotorValue, driveDeadbandThreshold);    // deadband the right motor vlaue 
    setDriveMotors(rightMotorValue, leftMotorValue); 
} 
  
  
// arm functions 
void setArmMotors( int value)  // lets you set the arm motor values in one call 
{ 
    motor[rightTopArm] = value;       // rightTopArm - 4 
    motor[rightBottomArm] = value;  // rightBottomArm - 5 
    motor[leftTopArm] = value;        // leftTopArm - 6 
    motor[leftBottomArm] = value;     // leftBottomArm - 7 
} 
  
void setArm() 
{ 
    int armJoystickY = vexRT[Ch2];       // read from the right joystick Y-axis (channel 2) 
    armJoystickY = deadband(armJoystickY, armDeadbandThreshold); // deadband for arm motors 
    setArmMotors(armJoystickY); 
} 
  
// this runs the arm with the left trigger buttons (5 Up and Down) 
// it only goes full speed but this will be fixed with PID later 
void setArm_button() 
{ 
    if(vexRT[Btn5U] == 1)           // if button 5 Up is pressed 
        { 
                setArmMotors(127); 
        } 
    else if(vexRT[Btn5D] == 1)  // if button 5 Down is pressed 
        { 
                setArmMotors(-127); 
        } 
    else                                                // if neither button is pressed 
        { 
            setArmMotors(0); 
        } 
} 
  
  
// intake functions 
void setIntakeMotors( int value) 
{ 
    motor[rightIntake]= value;  // rightIntake - 1 
    motor[leftIntake]= value;     // rightIntake - 10 
} 
  
void setIntake() 
{ 
    if(vexRT[Btn6U] == 1)           // if button 6 Up is pressed 
        {setIntakeMotors(127);}   // full forward 
    else if(vexRT[Btn6D] == 1)  // if button 6 Down is pressed 
        {setIntakeMotors(-127);}  // full reverse 
    else                                                // if neither button is pressed 
        {setIntakeMotors(0);}     // stop the motors 
} 
  
  
  
  
task main() 
{ 
  
  
  
    while (true)    // BLT 
    { 
  
  
  
  
  
// start drive code... 
        int driveJoystickY = vexRT[Ch3];  // originally divided by 2 to prevent numbers over 127 
        int driveJoystickX = vexRT[Ch4];  // originally divided by 2 to prevent numbers over 127 
    // we should add a clipping function - maybe combine with the deadband? 
  
        int rightMotorValue = driveJoystickY - driveJoystickX;  //arcade drive left side value 
        int leftMotorValue = driveJoystickY + driveJoystickX;       //arcade drive right side value 
    // this is standard arcade drive - it can be tweaked but it works fine 
  
        // implement deadband 
        if (abs(leftMotorValue) < driveDeadbandThreshold) 
        { 
            leftMotorValue = 0; 
        } 
        if (abs(rightMotorValue) < driveDeadbandThreshold) 
        { 
            rightMotorValue = 0; 
        } 
  
        // this sets the actual drive motor values 
        motor[rightFrontDrive] = rightMotorValue; 
        motor[rightBackDrive] = rightMotorValue; 
        motor[leftFrontDrive] = leftMotorValue; 
        motor[leftBackDrive] = leftMotorValue; 
// ...end drive code.  This will be replaced by setDrive() 
  
  
  
// start arm code... 
        // arm code - basically the same as old strafe wheel code 
        int armJoystickY = vexRT[Ch2];                  // read from the right joystick Y-axis (channel 4) 
        if (abs(armJoystickY) < armDeadbandThreshold) // deadband for arm motors 
        { 
            armJoystickY = 0; 
        } 
  
    // set arm motor values 
        if ( SensorValue(rightArmPot) > rightArmUpperLimit && armJoystickY > 0) // if we're above the upper limit and going up 
        { 
            armJoystickY = 0;       // set the arm value to 0 
        } 
        if ( SensorValue(rightArmPot) < rightArmLowerLimit && armJoystickY < 0) // if we're below the lower limit and going down 
        { 
            armJoystickY = 0;       // set the arm value to 0 
        } 
  
        motor[rightTopArm] = armJoystickY;       // rightTop - 4 
        motor[rightBottomArm] = armJoystickY;  // rightBottom - 5 
        motor[leftTopArm] = armJoystickY;          // leftTop - 6 
        motor[leftBottomArm] = armJoystickY;     // leftBottom - 7 
// ...end arm code.  This will be replaced by setArm() 
  
  
  
// start intake code... 
        if(vexRT[Btn6U] == 1)           // if button 6 Up is pressed 
        { 
            motor[rightIntake]= -127;   // set intake motors full reverse 
        motor[leftIntake]= -127; 
        } 
        else if(vexRT[Btn6D] == 1)  // if button 6 Down is pressed 
        { 
            motor[rightIntake]= 127;    // set intake motors full reverse 
        motor[leftIntake]= 127; 
        } 
        else                                                // if neither button is pressed 
        { 
            motor[rightIntake]= 0;      // stop intake motors 
        motor[leftIntake]= 0; 
        } 
// ...end intake code.  This will be replaced by setIntake() 
  
  
  
  
  
    } 
} 
